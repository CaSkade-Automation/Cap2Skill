{
    "ros2_control_entities": [
        {
            "name": "/cmd_vel",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/cmd_vel` topic is used to command the velocity of a mobile robot. It typically carries messages that specify the desired linear and angular velocities for the robot's movement.\n\nMobile Robot Module:\n    - This element relates to the motion control module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The `/cmd_vel` topic is crucial for tasks involving navigation and movement control. It allows for the implementation of path-following algorithms and obstacle avoidance by adjusting the robot's speed and direction.\n\nUsage in the ROS2 System:\n    - It is commonly used in ROS2 systems for tasks such as teleoperation, autonomous navigation, and dynamic path planning. Nodes like `move_base` or custom control nodes publish to this topic to control the robot's movement.",
            "interfaces": [
                {
                    "name": "geometry_msgs/msg/Twist",
                    "details": "# This expresses velocity in free space broken into its linear and angular parts.\n\nVector3  linear\n\tfloat64 x\n\tfloat64 y\n\tfloat64 z\nVector3  angular\n\tfloat64 x\n\tfloat64 y\n\tfloat64 z"
                }
            ]
        },
        {
            "name": "/dynamic_joint_states",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/dynamic_joint_states` topic provides real-time updates on the state of various joints in a robotic system. It is typically used to monitor and control the positions, velocities, and efforts of joints in robotic arms or manipulators.\n\nMobile Robot Module:\n    - This ROS2 element relates to the manipulator or arm module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - It is crucial for tasks involving precise joint control, such as pick-and-place operations, assembly tasks, or any application requiring dynamic adjustment of joint states. It helps in synchronizing joint movements and ensuring accurate execution of complex maneuvers.\n\nUsage in the ROS2 System:\n    - Suitable for use in ROS2 systems that require real-time feedback and control of robotic joints, such as robotic arms in manufacturing, service robots with manipulators, and research platforms for testing joint control algorithms.",
            "interfaces": [
                {
                    "name": "control_msgs/msg/DynamicJointState",
                    "details": "std_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# List of resource names, e.g. [\"arm_joint_1\", \"arm_joint_2\", \"gripper_joint\"]\nstring[] joint_names\n# Key-value pairs representing interfaces and their corresponding values for each joint listed in `joint_names`\nInterfaceValue[] interface_values\n\tstring[] interface_names\n\tfloat64[] values"
                }
            ]
        },
        {
            "name": "/global_costmap/costmap",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/global_costmap/costmap` topic provides a 2-D grid map representation of the environment, indicating occupied, unoccupied, and unknown areas. It is typically used for navigation and path planning tasks in mobile robots.\n\nMobile Robot Module:\n    - This element relates to the navigation and mapping modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - It is crucial for solving path planning and obstacle avoidance problems. The costmap helps the robot understand its environment and make decisions about safe paths to follow.\n\nUsage in the ROS2 System:\n    - Suitable for tasks such as autonomous navigation, where nodes like `move_base` or `nav2_planner` use this topic to plan and execute paths while avoiding obstacles.",
            "interfaces": [
                {
                    "name": "nav_msgs/msg/OccupancyGrid",
                    "details": "# This represents a 2-D grid map\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# MetaData for the map\nMapMetaData info\n\tbuiltin_interfaces/Time map_load_time\n\t\tint32 sec\n\t\tuint32 nanosec\n\tfloat32 resolution\n\tuint32 width\n\tuint32 height\n\tgeometry_msgs/Pose origin\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\n# The map data, in row-major order, starting with (0,0).\n# Cell (1, 0) will be listed second, representing the next cell in the x direction.\n# Cell (0, 1) will be at the index equal to info.width, followed by (1, 1).\n# The values inside are application dependent, but frequently,\n# 0 represents unoccupied, 1 represents definitely occupied, and\n# -1 represents unknown.\nint8[] data"
                }
            ]
        },
        {
            "name": "/global_costmap/costmap_updates",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/global_costmap/costmap_updates` topic is used to publish updates to the global costmap, which is a representation of the environment used for navigation and path planning. It provides incremental updates to the occupancy grid, allowing the robot to adjust its path based on new information.\n\nMobile Robot Module:\n    - This element relates to the Navigation and Path Planning module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - This topic is crucial for dynamic path planning and obstacle avoidance. It allows the robot to adapt to changes in the environment, such as moving obstacles or newly discovered areas, ensuring efficient and safe navigation.\n\nUsage in the ROS2 System:\n    - It is typically used in conjunction with navigation stacks like `nav2` to update the robot's understanding of its environment. It interacts with nodes responsible for path planning and obstacle avoidance, such as `move_base` or `planner_server`.",
            "interfaces": [
                {
                    "name": "map_msgs/msg/OccupancyGridUpdate",
                    "details": "std_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\nint32 x\nint32 y\nuint32 width\nuint32 height\nint8[] data"
                }
            ]
        },
        {
            "name": "/initialpose",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/initialpose` topic is used to set or update the initial pose of a mobile robot within a given reference frame. It is typically used to provide an estimated starting position and orientation for localization algorithms.\n\nMobile Robot Module:\n    - This element relates to the Localization module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The `/initialpose` topic is crucial for initializing the robot's position in a map, which is essential for accurate navigation and path planning. It is commonly used in scenarios where a robot needs to be manually set to a known position before starting autonomous operations.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as initializing the robot's position in SLAM (Simultaneous Localization and Mapping) systems or when using AMCL (Adaptive Monte Carlo Localization) for localization.",
            "interfaces": [
                {
                    "name": "geometry_msgs/msg/PoseWithCovarianceStamped",
                    "details": "# This expresses an estimated pose with a reference coordinate frame and timestamp\n\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\nPoseWithCovariance pose\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tfloat64[36] covariance"
                }
            ]
        },
        {
            "name": "/joint_states",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/joint_states` topic is used to convey the state of a set of torque-controlled joints, including their position, velocity, and effort. It is typically used for monitoring and controlling the movement of robotic joints.\n\nMobile Robot Module:\n    - This element relates to the actuation and motion control modules of a mobile robot, specifically those involving joint manipulation.\n\nRelevance for Specific Tasks:\n    - The `/joint_states` topic is crucial for tasks involving precise joint control, such as robotic arm manipulation, where feedback on joint positions, velocities, and efforts is necessary for accurate control and coordination.\n\nUsage in the ROS2 System:\n    - It is commonly used in ROS2 systems for tasks like robotic arm control, where nodes subscribe to this topic to receive real-time joint state information for feedback control loops and motion planning.",
            "interfaces": [
                {
                    "name": "sensor_msgs/msg/JointState",
                    "details": "# This is a message that holds data to describe the state of a set of torque controlled joints.\n#\n# The state of each joint (revolute or prismatic) is defined by:\n#  * the position of the joint (rad or m),\n#  * the velocity of the joint (rad/s or m/s) and\n#  * the effort that is applied in the joint (Nm or N).\n#\n# Each joint is uniquely identified by its name\n# The header specifies the time at which the joint states were recorded. All the joint states\n# in one message have to be recorded at the same time.\n#\n# This message consists of a multiple arrays, one for each part of the joint state.\n# The goal is to make each of the fields optional. When e.g. your joints have no\n# effort associated with them, you can leave the effort array empty.\n#\n# All arrays in this message should have the same size, or be empty.\n# This is the only way to uniquely associate the joint name with the correct\n# states.\n\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\nstring[] name\nfloat64[] position\nfloat64[] velocity\nfloat64[] effort"
                }
            ]
        },
        {
            "name": "/joint_trajectory_controller/controller_state",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/joint_trajectory_controller/controller_state` topic provides the current state of a joint trajectory controller, including desired, actual, and error states for joint positions, velocities, accelerations, and efforts. It is typically used for monitoring and adjusting the performance of joint controllers in robotic systems.\n\nMobile Robot Module:\n    - This element relates to the Actuation and Control module of a mobile robot, specifically focusing on joint control.\n\nRelevance for Specific Tasks:\n    - This topic is crucial for tasks involving precise joint control, such as robotic arm manipulation or mobile robot navigation where joint trajectories need to be accurately followed. It helps in diagnosing control errors and tuning controller parameters.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks like real-time feedback in robotic arms, ensuring accurate trajectory following, and integrating with higher-level control systems for coordinated motion planning.",
            "interfaces": [
                {
                    "name": "control_msgs/msg/JointTrajectoryControllerState",
                    "details": "# This message presents current controller state of JTC\n\n# Header timestamp should be update time of controller state\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\nstring[] joint_names\n# The set point, that is, desired state.\ntrajectory_msgs/JointTrajectoryPoint reference\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# Current value of the process (ie: latest sensor measurement on the controlled value).\ntrajectory_msgs/JointTrajectoryPoint feedback\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# The error of the controlled value, essentially reference - feedback (for a regular PID implementation).\ntrajectory_msgs/JointTrajectoryPoint error\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# Current output of the controller.\ntrajectory_msgs/JointTrajectoryPoint output\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# -- deprecated --\ntrajectory_msgs/JointTrajectoryPoint desired\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\ntrajectory_msgs/JointTrajectoryPoint actual\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n\nstring[] multi_dof_joint_names\n# The set point, that is, desired state.\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_reference\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# Current value of the process (ie: latest sensor measurement on the controlled value).\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_feedback\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# The error of the controlled value, essentially reference - feedback (for a regular PID implementation).\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_error\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# Current output of the controller.\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_output\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# -- deprecated --\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_desired\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_actual\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec"
                }
            ]
        },
        {
            "name": "/joint_trajectory_controller/joint_trajectory",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The \"/joint_trajectory_controller/joint_trajectory\" topic is used to send joint trajectory commands to a robot's joint trajectory controller. It specifies the desired positions, velocities, accelerations, and efforts for the robot's joints over time.\n    - It is typically used for executing complex motion plans that require precise control of joint movements.\n\nMobile Robot Module:\n    - This ROS2 element relates to the actuation module of a mobile robot, specifically the joint actuators.\n\nRelevance for Specific Tasks:\n    - This element is crucial for tasks involving precise joint control, such as robotic arm manipulation, path following, and coordinated multi-joint movements.\n    - It plays a role in scenarios where a robot needs to follow a predefined trajectory, such as in pick-and-place operations or when navigating through a series of waypoints.\n\nUsage in the ROS2 System:\n    - It is suitable for use in ROS2 systems that require joint trajectory control, such as robotic arms, humanoid robots, and any system with articulated joints. Typical entities interacting with this topic include trajectory planners and controllers.",
            "interfaces": [
                {
                    "name": "trajectory_msgs/msg/JointTrajectory",
                    "details": "# The header is used to specify the coordinate frame and the reference time for\n# the trajectory durations\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# The names of the active joints in each trajectory point. These names are\n# ordered and must correspond to the values in each trajectory point.\nstring[] joint_names\n\n# Array of trajectory points, which describe the positions, velocities,\n# accelerations and/or efforts of the joints at each time point.\nJointTrajectoryPoint[] points\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec"
                }
            ]
        },
        {
            "name": "/joint_trajectory_controller/state",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/joint_trajectory_controller/state` topic provides the current state of a joint trajectory controller, including desired, actual, and error states for joint positions, velocities, accelerations, and efforts.\n    - It is typically used for monitoring and feedback in control systems to ensure that joint movements follow the planned trajectory accurately.\n\nMobile Robot Module:\n    - This element relates to the Actuation and Control module of a mobile robot, specifically for joint control in robotic arms or similar mechanisms.\n\nRelevance for Specific Tasks:\n    - This topic is crucial for tasks requiring precise joint control, such as robotic arm manipulation, where feedback on joint states is necessary to adjust control commands and minimize errors.\n    - It plays a role in scenarios where real-time monitoring and adjustment of joint trajectories are needed to achieve desired outcomes.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving joint trajectory execution and feedback, such as robotic arm control in manufacturing or service robots.\n    - Commonly used by nodes implementing control algorithms that require real-time state feedback to adjust commands dynamically.",
            "interfaces": [
                {
                    "name": "control_msgs/msg/JointTrajectoryControllerState",
                    "details": "# This message presents current controller state of JTC\n\n# Header timestamp should be update time of controller state\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\nstring[] joint_names\n# The set point, that is, desired state.\ntrajectory_msgs/JointTrajectoryPoint reference\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# Current value of the process (ie: latest sensor measurement on the controlled value).\ntrajectory_msgs/JointTrajectoryPoint feedback\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# The error of the controlled value, essentially reference - feedback (for a regular PID implementation).\ntrajectory_msgs/JointTrajectoryPoint error\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# Current output of the controller.\ntrajectory_msgs/JointTrajectoryPoint output\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# -- deprecated --\ntrajectory_msgs/JointTrajectoryPoint desired\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\ntrajectory_msgs/JointTrajectoryPoint actual\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n\nstring[] multi_dof_joint_names\n# The set point, that is, desired state.\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_reference\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# Current value of the process (ie: latest sensor measurement on the controlled value).\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_feedback\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# The error of the controlled value, essentially reference - feedback (for a regular PID implementation).\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_error\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# Current output of the controller.\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_output\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n# -- deprecated --\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_desired\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_actual\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec"
                }
            ]
        },
        {
            "name": "/joint_trajectory_controller/transition_event",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/joint_trajectory_controller/transition_event` topic is used to communicate lifecycle transition events of a joint trajectory controller. It provides information about the state changes of the controller, such as activation, deactivation, and shutdown.\n\nMobile Robot Module:\n    - This element relates to the control module of a mobile robot, specifically the joint trajectory controller responsible for managing the robot's joint movements.\n\nRelevance for Specific Tasks:\n    - This element is crucial for monitoring and managing the state transitions of the joint trajectory controller, ensuring that the controller is in the correct state for executing movement commands. It is relevant in scenarios where precise control over the robot's joint states is required, such as in robotic arms or mobile platforms with articulated joints.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks involving lifecycle management of controllers, such as initializing, configuring, and safely shutting down the joint trajectory controller. It is typically used by lifecycle management nodes and monitoring tools within a ROS2 system.",
            "interfaces": [
                {
                    "name": "lifecycle_msgs/msg/TransitionEvent",
                    "details": "# The time point at which this event occurred.\nuint64 timestamp\n\n# The id and label of this transition event.\nTransition transition\n\tuint8 TRANSITION_CREATE = 0\n\tuint8 TRANSITION_CONFIGURE = 1\n\tuint8 TRANSITION_CLEANUP = 2\n\tuint8 TRANSITION_ACTIVATE = 3\n\tuint8 TRANSITION_DEACTIVATE = 4\n\tuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\tuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\tuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\tuint8 TRANSITION_DESTROY = 8\n\tuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\n\tuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\n\tuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\tuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\n\tuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\n\tuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\tuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\n\tuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\n\tuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\tuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\n\tuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\n\tuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\tuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\n\tuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\n\tuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\tuint8 TRANSITION_ON_ERROR_SUCCESS = 60\n\tuint8 TRANSITION_ON_ERROR_FAILURE = 61\n\tuint8 TRANSITION_ON_ERROR_ERROR = 62\n\tuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\tuint8 TRANSITION_CALLBACK_FAILURE = 98\n\tuint8 TRANSITION_CALLBACK_ERROR = 99\n\t##\n\t##\n\tuint8 id\n\tstring label\n\n# The starting state from which this event transitioned.\nState start_state\n\tuint8 PRIMARY_STATE_UNKNOWN = 0\n\tuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\tuint8 PRIMARY_STATE_INACTIVE = 2\n\tuint8 PRIMARY_STATE_ACTIVE = 3\n\tuint8 PRIMARY_STATE_FINALIZED = 4\n\tuint8 TRANSITION_STATE_CONFIGURING = 10\n\tuint8 TRANSITION_STATE_CLEANINGUP = 11\n\tuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\tuint8 TRANSITION_STATE_ACTIVATING = 13\n\tuint8 TRANSITION_STATE_DEACTIVATING = 14\n\tuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\tuint8 id\n\tstring label\n\n# The end state of this transition event.\nState goal_state\n\tuint8 PRIMARY_STATE_UNKNOWN = 0\n\tuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\tuint8 PRIMARY_STATE_INACTIVE = 2\n\tuint8 PRIMARY_STATE_ACTIVE = 3\n\tuint8 PRIMARY_STATE_FINALIZED = 4\n\tuint8 TRANSITION_STATE_CONFIGURING = 10\n\tuint8 TRANSITION_STATE_CLEANINGUP = 11\n\tuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\tuint8 TRANSITION_STATE_ACTIVATING = 13\n\tuint8 TRANSITION_STATE_DEACTIVATING = 14\n\tuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\tuint8 id\n\tstring label"
                }
            ]
        },
        {
            "name": "/local_costmap/costmap",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/local_costmap/costmap` topic provides a 2-D grid map representation of the local environment around the robot. It is typically used for navigation and obstacle avoidance by representing occupied, unoccupied, and unknown areas.\n\nMobile Robot Module:\n    - This element relates to the navigation and perception modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - It is crucial for tasks involving path planning and real-time obstacle avoidance. The costmap helps the robot understand its immediate surroundings and make decisions to navigate safely.\n\nUsage in the ROS2 System:\n    - This topic is commonly used in navigation stacks, such as `nav2`, where it interacts with planners and controllers to facilitate autonomous navigation and collision avoidance.",
            "interfaces": [
                {
                    "name": "nav_msgs/msg/OccupancyGrid",
                    "details": "# This represents a 2-D grid map\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# MetaData for the map\nMapMetaData info\n\tbuiltin_interfaces/Time map_load_time\n\t\tint32 sec\n\t\tuint32 nanosec\n\tfloat32 resolution\n\tuint32 width\n\tuint32 height\n\tgeometry_msgs/Pose origin\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\n# The map data, in row-major order, starting with (0,0).\n# Cell (1, 0) will be listed second, representing the next cell in the x direction.\n# Cell (0, 1) will be at the index equal to info.width, followed by (1, 1).\n# The values inside are application dependent, but frequently,\n# 0 represents unoccupied, 1 represents definitely occupied, and\n# -1 represents unknown.\nint8[] data"
                }
            ]
        },
        {
            "name": "/local_costmap/costmap_updates",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/local_costmap/costmap_updates` topic is used to provide updates to the local costmap, which is a grid representation of the environment around the robot. It is typically used to reflect changes in the environment, such as obstacles appearing or disappearing.\n\nMobile Robot Module:\n    - This element relates to the Navigation module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - This ROS2 element is crucial for dynamic path planning and obstacle avoidance. It allows the robot to adapt its path in real-time as the environment changes, ensuring safe and efficient navigation.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as real-time navigation, dynamic obstacle avoidance, and adaptive path planning. Typical ROS2 entities that interact with this element include navigation nodes like `nav2_controller` and `nav2_planner`.",
            "interfaces": [
                {
                    "name": "map_msgs/msg/OccupancyGridUpdate",
                    "details": "std_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\nint32 x\nint32 y\nuint32 width\nuint32 height\nint8[] data"
                }
            ]
        },
        {
            "name": "/local_costmap/published_footprint",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/local_costmap/published_footprint` topic publishes the footprint of the robot as a polygon, which includes the reference coordinate frame and timestamp. It is typically used to represent the area occupied by the robot in the environment.\n\nMobile Robot Module:\n    - This element relates to the navigation and obstacle avoidance modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - It helps in collision avoidance and path planning by providing the robot's current footprint, allowing the system to understand the space the robot occupies. This is crucial for tasks that require precise navigation in dynamic environments.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as dynamic path planning, real-time obstacle avoidance, and ensuring safe navigation in environments with moving obstacles.",
            "interfaces": [
                {
                    "name": "geometry_msgs/msg/PolygonStamped",
                    "details": "# This represents a Polygon with reference coordinate frame and timestamp\n\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\nPolygon polygon\n\tPoint32[] points\n\t\t#\n\t\t#\n\t\tfloat32 x\n\t\tfloat32 y\n\t\tfloat32 z"
                }
            ]
        },
        {
            "name": "/local_plan",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/local_plan` topic is used to publish a sequence of poses that form a path for a robot to follow. It is typically used for local path planning, allowing the robot to navigate through its environment by following the specified path.\n\nMobile Robot Module:\n    - This element relates to the navigation module of a mobile robot, specifically the local planner component.\n\nRelevance for Specific Tasks:\n    - The `/local_plan` topic is crucial for tasks involving real-time path adjustments and obstacle avoidance. It helps in dynamically updating the robot's path based on sensor inputs and environmental changes.\n\nUsage in the ROS2 System:\n    - It is commonly used in navigation stacks like `nav2` for tasks such as local path planning and execution. It interacts with other components like the local planner and controller to ensure smooth and efficient navigation.",
            "interfaces": [
                {
                    "name": "nav_msgs/msg/Path",
                    "details": "# An array of poses that represents a Path for a robot to follow.\n\n# Indicates the frame_id of the path.\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# Array of poses to follow.\ngeometry_msgs/PoseStamped[] poses\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1"
                }
            ]
        },
        {
            "name": "/map",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/map` topic provides a 2-D grid map representation of the environment using the `nav_msgs/msg/OccupancyGrid` message type. It is typically used for navigation and localization tasks, allowing robots to understand and interact with their surroundings.\n\nMobile Robot Module:\n    - This element relates to the Navigation and Perception modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The `/map` topic is crucial for path planning, obstacle avoidance, and localization. It helps in determining free and occupied spaces, enabling the robot to navigate efficiently and safely.\n\nUsage in the ROS2 System:\n    - It is commonly used in tasks such as autonomous navigation, SLAM (Simultaneous Localization and Mapping), and environment mapping. Nodes like `move_base` and `amcl` (Adaptive Monte Carlo Localization) typically interact with this topic.",
            "interfaces": [
                {
                    "name": "nav_msgs/msg/OccupancyGrid",
                    "details": "# This represents a 2-D grid map\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# MetaData for the map\nMapMetaData info\n\tbuiltin_interfaces/Time map_load_time\n\t\tint32 sec\n\t\tuint32 nanosec\n\tfloat32 resolution\n\tuint32 width\n\tuint32 height\n\tgeometry_msgs/Pose origin\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\n# The map data, in row-major order, starting with (0,0).\n# Cell (1, 0) will be listed second, representing the next cell in the x direction.\n# Cell (0, 1) will be at the index equal to info.width, followed by (1, 1).\n# The values inside are application dependent, but frequently,\n# 0 represents unoccupied, 1 represents definitely occupied, and\n# -1 represents unknown.\nint8[] data"
                }
            ]
        },
        {
            "name": "/map_metadata",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n   - The `/map_metadata` topic provides essential metadata about an occupancy grid map, including map resolution, dimensions, and origin. It is typically used to understand the characteristics of the map being utilized for navigation and localization tasks.\n\nMobile Robot Module:\n   - This element relates to the Navigation and Localization modules of a mobile robot.\n\nRelevance for Specific Tasks:\n   - It is crucial for tasks involving path planning and obstacle avoidance, as it provides the necessary context for interpreting the occupancy grid. It helps in aligning the robot's position with the map and planning efficient routes.\n\nUsage in the ROS2 System:\n   - Suitable for use in navigation stacks like `nav2` where it assists in map-based navigation tasks, ensuring the robot can accurately interpret and utilize the map data for movement and decision-making.",
            "interfaces": [
                {
                    "name": "nav_msgs/msg/MapMetaData",
                    "details": "# This hold basic information about the characteristics of the OccupancyGrid\n\n# The time at which the map was loaded\nbuiltin_interfaces/Time map_load_time\n\tint32 sec\n\tuint32 nanosec\n\n# The map resolution [m/cell]\nfloat32 resolution\n\n# Map width [cells]\nuint32 width\n\n# Map height [cells]\nuint32 height\n\n# The origin of the map [m, m, rad].  This is the real-world pose of the\n# bottom left corner of cell (0,0) in the map.\ngeometry_msgs/Pose origin\n\tPoint position\n\t\tfloat64 x\n\t\tfloat64 y\n\t\tfloat64 z\n\tQuaternion orientation\n\t\tfloat64 x 0\n\t\tfloat64 y 0\n\t\tfloat64 z 0\n\t\tfloat64 w 1"
                }
            ]
        },
        {
            "name": "/map_updates",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/map_updates` topic is used to communicate updates to an occupancy grid map, which represents the environment in terms of occupied and free spaces. It is typically used for updating the map with new information as the robot navigates.\n\nMobile Robot Module:\n    - This element relates to the Navigation and Mapping module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The `/map_updates` topic is crucial for tasks involving dynamic mapping and navigation, where the robot needs to adapt to changes in the environment. It helps in maintaining an up-to-date map for path planning and obstacle avoidance.\n\nUsage in the ROS2 System:\n    - It is suitable for use in autonomous navigation systems, where nodes like map servers or SLAM (Simultaneous Localization and Mapping) algorithms publish updates to the map, and navigation nodes subscribe to these updates to adjust their path planning accordingly.",
            "interfaces": [
                {
                    "name": "map_msgs/msg/OccupancyGridUpdate",
                    "details": "std_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\nint32 x\nint32 y\nuint32 width\nuint32 height\nint8[] data"
                }
            ]
        },
        {
            "name": "/mobile_base/sensors/bumper_pointcloud",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/mobile_base/sensors/bumper_pointcloud` topic publishes point cloud data from the robot's bumper sensors. It is typically used for obstacle detection and navigation.\n\nMobile Robot Module:\n    - This element relates to the sensor module of the mobile robot, specifically the bumper sensors.\n\nRelevance for Specific Tasks:\n    - This ROS2 element is crucial for tasks involving collision avoidance and environment mapping. It helps in detecting obstacles and planning safe paths for the robot.\n\nUsage in the ROS2 System:\n    - It is suitable for use in navigation stacks, such as `nav2`, where real-time obstacle detection and avoidance are required. It can also be used in SLAM (Simultaneous Localization and Mapping) applications to build a map of the environment.",
            "interfaces": [
                {
                    "name": "sensor_msgs/msg/PointCloud2",
                    "details": "# This message holds a collection of N-dimensional points, which may\n# contain additional information such as normals, intensity, etc. The\n# point data is stored as a binary blob, its layout described by the\n# contents of the \"fields\" array.\n#\n# The point cloud data may be organized 2d (image-like) or 1d (unordered).\n# Point clouds organized as 2d images may be produced by camera depth sensors\n# such as stereo or time-of-flight.\n\n# Time of sensor data acquisition, and the coordinate frame ID (for 3d points).\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# 2D structure of the point cloud. If the cloud is unordered, height is\n# 1 and width is the length of the point cloud.\nuint32 height\nuint32 width\n\n# Describes the channels and their layout in the binary data blob.\nPointField[] fields\n\tuint8 INT8    = 1\n\tuint8 UINT8   = 2\n\tuint8 INT16   = 3\n\tuint8 UINT16  = 4\n\tuint8 INT32   = 5\n\tuint8 UINT32  = 6\n\tuint8 FLOAT32 = 7\n\tuint8 FLOAT64 = 8\n\tstring name      #\n\tuint32 offset    #\n\tuint8  datatype  #\n\tuint32 count     #\n\nbool    is_bigendian # Is this data bigendian?\nuint32  point_step   # Length of a point in bytes\nuint32  row_step     # Length of a row in bytes\nuint8[] data         # Actual point data, size is (row_step*height)\n\nbool is_dense        # True if there are no invalid points"
                }
            ]
        },
        {
            "name": "/odom",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/odom` topic provides an estimate of a mobile robot's position and velocity in free space. It is typically used for tracking the robot's movement and updating its position relative to a fixed world frame.\n\nMobile Robot Module:\n    - This element relates to the Localization and Navigation modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The `/odom` topic is crucial for tasks involving navigation, path planning, and obstacle avoidance. It helps in maintaining an accurate estimate of the robot's pose and velocity, which is essential for precise control and movement.\n\nUsage in the ROS2 System:\n    - It is commonly used in ROS2 systems for tasks such as autonomous navigation, SLAM (Simultaneous Localization and Mapping), and dynamic path adjustment. Typical entities interacting with this topic include navigation nodes, localization algorithms, and control systems.",
            "interfaces": [
                {
                    "name": "nav_msgs/msg/Odometry",
                    "details": "# This represents an estimate of a position and velocity in free space.\n# The pose in this message should be specified in the coordinate frame given by header.frame_id\n# The twist in this message should be specified in the coordinate frame given by the child_frame_id\n\n# Includes the frame id of the pose parent.\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# Frame id the pose points to. The twist is in this coordinate frame.\nstring child_frame_id\n\n# Estimated pose that is typically relative to a fixed world frame.\ngeometry_msgs/PoseWithCovariance pose\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tfloat64[36] covariance\n\n# Estimated linear and angular velocity relative to child_frame_id.\ngeometry_msgs/TwistWithCovariance twist\n\tTwist twist\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tfloat64[36] covariance"
                }
            ]
        },
        {
            "name": "/particle_cloud",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/particle_cloud` topic is used to represent a collection of particles, each with a pose and weight, which are typically used in probabilistic localization algorithms like particle filters.\n    - It is used for estimating the position and orientation of a mobile robot within a map.\n\nMobile Robot Module:\n    - This element relates to the Localization module of a Mobile Robot.\n\nRelevance for Specific Tasks:\n    - It helps solve the problem of determining a robot's position in an environment by maintaining a set of hypotheses (particles) about the robot's location.\n    - It is crucial in scenarios where the robot needs to navigate through an environment with uncertain initial positioning.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving adaptive Monte Carlo localization (AMCL) and other particle filter-based localization methods.",
            "interfaces": [
                {
                    "name": "nav2_msgs/msg/ParticleCloud",
                    "details": "# This represents a particle cloud containing particle poses and weights\n\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# Array of particles in the cloud\nParticle[] particles\n\tgeometry_msgs/Pose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tfloat64 weight"
                }
            ]
        },
        {
            "name": "/plan",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The \"/plan\" topic is used to communicate a sequence of poses that form a path for a robot to follow. It is typically used for path planning and navigation tasks, providing the robot with a predefined route to reach a destination.\n\nMobile Robot Module:\n    - This element relates to the Navigation module of a mobile robot, as it provides the path that the robot should follow to move from one location to another.\n\nRelevance for Specific Tasks:\n    - The \"/plan\" topic is crucial for solving path planning problems, enabling the robot to navigate through an environment efficiently. It is used in scenarios where a robot needs to autonomously travel from a start point to a goal point, avoiding obstacles along the way.\n\nUsage in the ROS2 System:\n    - This topic is commonly used in conjunction with path planners and navigation stacks, such as the ROS2 Navigation Stack (Nav2), to facilitate autonomous navigation tasks. It interacts with nodes responsible for path generation and execution.",
            "interfaces": [
                {
                    "name": "nav_msgs/msg/Path",
                    "details": "# An array of poses that represents a Path for a robot to follow.\n\n# Indicates the frame_id of the path.\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n\n# Array of poses to follow.\ngeometry_msgs/PoseStamped[] poses\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1"
                }
            ]
        },
        {
            "name": "/pose",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The `/pose` topic provides an estimated pose of the robot, including position and orientation, with a reference coordinate frame and timestamp. \n    - It is typically used for localization and navigation tasks, helping the robot understand its position in the environment.\n\nMobile Robot Module:\n    - This element relates to the Localization and Navigation modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The `/pose` topic is crucial for solving problems related to determining the robot's current position and orientation, which is essential for path planning and obstacle avoidance.\n    - It plays a role in scenarios where the robot needs to navigate through an environment, update its position, or adjust its path based on its current pose.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as autonomous navigation, SLAM (Simultaneous Localization and Mapping), and dynamic path planning. Typical ROS2 entities that use this topic include navigation stacks and localization nodes.",
            "interfaces": [
                {
                    "name": "geometry_msgs/msg/PoseWithCovarianceStamped",
                    "details": "# This expresses an estimated pose with a reference coordinate frame and timestamp\n\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\nPoseWithCovariance pose\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tfloat64[36] covariance"
                }
            ]
        },
        {
            "name": "/scan",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The \"/scan\" topic provides data from a planar laser range-finder, commonly known as a LiDAR. It is typically used for detecting obstacles and mapping the environment by providing distance measurements from the sensor to surrounding objects.\n\nMobile Robot Module:\n    - This ROS2 element relates to the Perception and Navigation modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The \"/scan\" topic is crucial for tasks such as obstacle avoidance, environment mapping, and localization. It helps in creating a real-time map of the surroundings and detecting obstacles to navigate safely.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks like Simultaneous Localization and Mapping (SLAM), autonomous navigation, and collision avoidance. Typical ROS2 entities that use this topic include navigation stacks, SLAM algorithms, and obstacle detection nodes.",
            "interfaces": [
                {
                    "name": "sensor_msgs/msg/LaserScan",
                    "details": "# Single scan from a planar laser range-finder\n#\n# If you have another ranging device with different behavior (e.g. a sonar\n# array), please find or create a different message, since applications\n# will make fairly laser-specific assumptions about this data\n\nstd_msgs/Header header # timestamp in the header is the acquisition time of\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n                             # the first ray in the scan.\n                             #\n                             # in frame frame_id, angles are measured around\n                             # the positive Z axis (counterclockwise, if Z is up)\n                             # with zero angle being forward along the x axis\n\nfloat32 angle_min            # start angle of the scan [rad]\nfloat32 angle_max            # end angle of the scan [rad]\nfloat32 angle_increment      # angular distance between measurements [rad]\n\nfloat32 time_increment       # time between measurements [seconds] - if your scanner\n                             # is moving, this will be used in interpolating position\n                             # of 3d points\nfloat32 scan_time            # time between scans [seconds]\n\nfloat32 range_min            # minimum range value [m]\nfloat32 range_max            # maximum range value [m]\n\nfloat32[] ranges             # range data [m]\n                             # (Note: values < range_min or > range_max should be discarded)\nfloat32[] intensities        # intensity data [device-specific units].  If your\n                             # device does not provide intensities, please leave\n                             # the array empty."
                }
            ]
        },
        {
            "name": "/scan2",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The \"/scan2\" topic is used to publish data from a planar laser range-finder, providing information about the surrounding environment. It is typically used for obstacle detection and navigation.\n\nMobile Robot Module:\n    - This ROS2 element relates to the perception and navigation modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The \"/scan2\" topic is crucial for tasks such as mapping, localization, and path planning. It helps in detecting obstacles and understanding the robot's environment, enabling safe and efficient navigation.\n\nUsage in the ROS2 System:\n    - It is suitable for use in tasks like SLAM (Simultaneous Localization and Mapping), autonomous navigation, and collision avoidance. Nodes that perform these tasks will subscribe to the \"/scan2\" topic to receive laser scan data.",
            "interfaces": [
                {
                    "name": "sensor_msgs/msg/LaserScan",
                    "details": "# Single scan from a planar laser range-finder\n#\n# If you have another ranging device with different behavior (e.g. a sonar\n# array), please find or create a different message, since applications\n# will make fairly laser-specific assumptions about this data\n\nstd_msgs/Header header # timestamp in the header is the acquisition time of\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\n                             # the first ray in the scan.\n                             #\n                             # in frame frame_id, angles are measured around\n                             # the positive Z axis (counterclockwise, if Z is up)\n                             # with zero angle being forward along the x axis\n\nfloat32 angle_min            # start angle of the scan [rad]\nfloat32 angle_max            # end angle of the scan [rad]\nfloat32 angle_increment      # angular distance between measurements [rad]\n\nfloat32 time_increment       # time between measurements [seconds] - if your scanner\n                             # is moving, this will be used in interpolating position\n                             # of 3d points\nfloat32 scan_time            # time between scans [seconds]\n\nfloat32 range_min            # minimum range value [m]\nfloat32 range_max            # maximum range value [m]\n\nfloat32[] ranges             # range data [m]\n                             # (Note: values < range_min or > range_max should be discarded)\nfloat32[] intensities        # intensity data [device-specific units].  If your\n                             # device does not provide intensities, please leave\n                             # the array empty."
                }
            ]
        },
        {
            "name": "/tf",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The \"/tf\" topic is used to broadcast coordinate frame transformations in a ROS2 system. It is essential for maintaining the spatial relationships between different parts of a robot or between the robot and its environment.\n    - It is typically used for tasks that require understanding the position and orientation of various robot components or objects in the environment.\n\nMobile Robot Module:\n    - This element relates to the localization and navigation modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - The \"/tf\" topic is crucial for solving problems related to robot localization, navigation, and motion planning. It helps in transforming coordinates from one frame to another, which is vital for accurate movement and interaction with the environment.\n    - Typical scenarios include robot path planning, obstacle avoidance, and sensor data integration.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as integrating sensor data from different sources, coordinating multi-robot systems, and ensuring accurate robot movement by providing real-time transformation data.",
            "interfaces": [
                {
                    "name": "tf2_msgs/msg/TFMessage",
                    "details": "geometry_msgs/TransformStamped[] transforms\n\t#\n\t#\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tstring child_frame_id\n\tTransform transform\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1"
                }
            ]
        },
        {
            "name": "/tf_static",
            "type": "topic",
            "description": "Purpose of the ROS2 Element:\n    - The /tf_static topic is used to broadcast static coordinate transforms in a ROS2 system. It is typically used to define fixed relationships between different frames of reference, such as the position of sensors relative to the robot base.\n\nMobile Robot Module:\n    - This element relates to the localization and navigation modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - It solves the problem of maintaining consistent spatial relationships between different parts of the robot and its environment. It is crucial for tasks that require precise positioning and orientation, such as mapping and path planning.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks like sensor fusion, where multiple sensor data need to be integrated, and for navigation systems that require a stable reference frame for accurate movement and positioning.",
            "interfaces": [
                {
                    "name": "tf2_msgs/msg/TFMessage",
                    "details": "geometry_msgs/TransformStamped[] transforms\n\t#\n\t#\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tstring child_frame_id\n\tTransform transform\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1"
                }
            ]
        },
        {
            "name": "/apply_joint_effort",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/apply_joint_effort` service is used to apply a specified effort (force or torque) to a joint in a simulation environment, such as Gazebo. It allows for precise control over the movement and behavior of robotic joints by setting the effort, start time, and duration of application.\n\nMobile Robot Module:\n    - This service relates to the Actuation module of a mobile robot, specifically focusing on joint control.\n\nRelevance for Specific Tasks:\n    - It is relevant for tasks that require dynamic control of joint movements, such as simulating robotic arm operations or testing joint responses under different force conditions. It is crucial for scenarios where precise joint manipulation is needed, such as in robotic arm simulations or mobile robot steering mechanisms.\n\nUsage in the ROS2 System:\n    - This service is typically used in simulation environments like Gazebo to test and validate control algorithms, perform dynamic simulations, and develop control strategies for robotic joints. It is suitable for tasks involving joint actuation and control in simulated environments.",
            "interfaces": [
                {
                    "name": "gazebo_msgs/srv/ApplyJointEffort",
                    "details": "# set urdf joint effort\nstring joint_name                       # joint to apply wrench (linear force and torque)\nfloat64 effort                          # effort to apply\nbuiltin_interfaces/Time start_time      # optional wrench application start time (seconds)\n\tint32 sec\n\tuint32 nanosec\n                                        # if start_time < current time, start as soon as possible\nbuiltin_interfaces/Duration  duration   # optional duration of wrench application time (seconds)\n\tint32 sec\n\tuint32 nanosec\n                                        # if duration < 0, apply wrench continuously without end\n                                        # if duration = 0, do nothing\n                                        # if duration < step size, assume step size and\n                                        # display warning in status_message\n---\nbool success                            # return true if effort application is successful\nstring status_message                   # comments if available"
                }
            ]
        },
        {
            "name": "/apply_link_wrench",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/apply_link_wrench` service is used to apply a specified wrench, which includes linear force and torque, to a link in a Gazebo simulation. It is typically used to simulate physical interactions or forces acting on a robot or its components within the Gazebo environment.\n\nMobile Robot Module:\n    - This service relates to the actuation and simulation module of a mobile robot, specifically within the context of a simulated environment like Gazebo.\n\nRelevance for Specific Tasks:\n    - This service is relevant for tasks involving the simulation of physical forces and torques on robot components, such as testing the robot's response to external forces or simulating environmental interactions. It is crucial for validating control algorithms in a simulated setting before deploying them in real-world scenarios.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as testing control strategies, simulating dynamic interactions, and validating the mechanical design of robots in Gazebo. Typical users include developers working on robot simulation, control engineers, and researchers in robotics.",
            "interfaces": [
                {
                    "name": "gazebo_msgs/srv/ApplyLinkWrench",
                    "details": "# Apply Wrench to Gazebo Link.\n# via the callback mechanism\n# all Gazebo operations are made in world frame\nstring link_name                          # Gazebo link to apply wrench (linear force and torque)\n                                          # wrench is applied in the gazebo world by default\n                                          # link names are prefixed by model name, e.g. pr2::base_link\nstring reference_frame                    # wrench is defined in the reference frame of this entity\n                                          # use inertial frame if left empty\n                                          # frame names are links prefixed by model name, e.g. pr2::base_link\ngeometry_msgs/Point  reference_point      # wrench is defined at this location in the reference frame\n\tfloat64 x\n\tfloat64 y\n\tfloat64 z\ngeometry_msgs/Wrench wrench               # wrench applied to the origin of the link\n\tVector3  force\n\t\tfloat64 x\n\t\tfloat64 y\n\t\tfloat64 z\n\tVector3  torque\n\t\tfloat64 x\n\t\tfloat64 y\n\t\tfloat64 z\nbuiltin_interfaces/Time start_time        # (optional) wrench application start time (seconds)\n\tint32 sec\n\tuint32 nanosec\n                                          # if start_time is not specified, or\n                                          # start_time < current time, start as soon as possible\nbuiltin_interfaces/Duration duration      # optional duration of wrench application time (seconds)\n\tint32 sec\n\tuint32 nanosec\n                                          # if duration < 0, apply wrench continuously without end\n                                          # if duration = 0, do nothing\n                                          # if duration < step size, apply wrench\n                                          # for one step size\n---\nbool success                              # return true if set wrench successful\nstring status_message                     # comments if available"
                }
            ]
        },
        {
            "name": "/clear_joint_efforts",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/clear_joint_efforts` service is used to reset or clear the efforts applied to a specific joint in a simulation environment. It is typically used to stop any forces or torques being applied to a joint, effectively bringing it to a neutral state.\n\nMobile Robot Module:\n    - This service relates to the actuation module of a mobile robot, specifically the joints that are part of the robot's mechanical structure.\n\nRelevance for Specific Tasks:\n    - This service is useful for tasks that require resetting the state of a robot's joints, such as during the initialization phase of a simulation or when transitioning between different control modes. It ensures that no residual forces affect the robot's movement.\n\nUsage in the ROS2 System:\n    - It is suitable for simulation environments using Gazebo, where precise control over joint states is necessary. Typical users include simulation controllers and automated testing scripts that need to manage joint states dynamically.",
            "interfaces": [
                {
                    "name": "gazebo_msgs/srv/JointRequest",
                    "details": "string joint_name   # name of the joint requested\n---"
                }
            ]
        },
        {
            "name": "/controller_manager/configure_controller",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/controller_manager/configure_controller` service is used to configure a specific controller within the controller manager. It allows users to specify the name of the controller to be configured and returns a boolean indicating success.\n\nMobile Robot Module:\n   - This service relates to the control module of a mobile robot, specifically the controller management aspect.\n\nRelevance for Specific Tasks:\n   - This service is crucial for tasks that require dynamic reconfiguration of controllers, such as adapting to different operational modes or environments. It is used in scenarios where controllers need to be adjusted or initialized to meet specific control requirements.\n\nUsage in the ROS2 System:\n   - It is suitable for tasks involving the setup and management of controllers in a ROS2 system, such as initializing controllers during startup or reconfiguring them during runtime for adaptive control strategies.",
            "interfaces": [
                {
                    "name": "controller_manager_msgs/srv/ConfigureController",
                    "details": "# The ConfigureController service allows you to configure a single controller\n# inside controller_manager\n\n# To configure a controller, specify the \"name\" of the controller.\n# The return value \"ok\" indicates if the controller was successfully\n# configured or not.\n\nstring name\n---\nbool ok"
                }
            ]
        },
        {
            "name": "/controller_manager/list_controllers",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/controller_manager/list_controllers` service provides a list of controllers, including their names, states, and types, that are currently loaded in the controller manager. It is typically used to monitor and manage the controllers within a robotic system.\n\nMobile Robot Module:\n   - This service relates to the control module of a mobile robot, specifically the controller management aspect.\n\nRelevance for Specific Tasks:\n   - This service is crucial for tasks involving the management and orchestration of multiple controllers, such as dynamically loading, unloading, or switching controllers based on the robot's operational needs. It helps in ensuring that the correct controllers are active and functioning as expected.\n\nUsage in the ROS2 System:\n   - It is suitable for tasks like system diagnostics, controller lifecycle management, and ensuring the correct configuration of controllers in a ROS2-based robotic system.",
            "interfaces": [
                {
                    "name": "controller_manager_msgs/srv/ListControllers",
                    "details": "# The ListControllers service returns a list of controller names/states/types of the\n# controllers that are loaded inside the controller_manager.\n\n---\ncontroller_manager_msgs/ControllerState[] controller\n\tstring name        #\n\tstring state        #\n\tstring type        #\n\tstring[] claimed_interfaces        #\n\tstring[] required_command_interfaces        #\n\tstring[] required_state_interfaces        #\n\tbool is_chainable        #\n\tbool is_chained        #\n\tstring[] reference_interfaces        #\n\tChainConnection[] chain_connections        #\n\t\tstring name        #\n\t\tstring[] reference_interfaces        #"
                }
            ]
        },
        {
            "name": "/controller_manager/list_hardware_interfaces",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/controller_manager/list_hardware_interfaces` service is used to list all available hardware interfaces in a ROS2 system. It provides details about command and state interfaces, including their availability and claim status.\n    - It is typically used for managing and monitoring hardware interfaces in robotic systems.\n\nMobile Robot Module:\n    - This ROS2 element relates to the hardware interface module of a mobile robot, which includes actuators and sensors.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks involving the configuration and management of hardware interfaces, ensuring that the correct interfaces are available and properly claimed for control tasks.\n    - It plays a role in scenarios where dynamic reconfiguration or verification of hardware interfaces is required, such as during system initialization or when changing control strategies.\n\nUsage in the ROS2 System:\n    - Suitable for tasks like initializing the robot's control system, verifying hardware interface availability, and dynamically managing hardware resources in a ROS2-based robotic system.",
            "interfaces": [
                {
                    "name": "controller_manager_msgs/srv/ListHardwareInterfaces",
                    "details": "---\nHardwareInterface[] command_interfaces\n\tstring name\n\tbool is_available\n\tbool is_claimed\nHardwareInterface[] state_interfaces\n\tstring name\n\tbool is_available\n\tbool is_claimed"
                }
            ]
        },
        {
            "name": "/controller_manager/load_controller",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/controller_manager/load_controller` service is used to load a specific controller within the controller manager. It is typically used to dynamically add controllers to a running system, allowing for flexible and adaptive control strategies.\n\nMobile Robot Module:\n   - This service relates to the control module of a mobile robot, specifically the controller management aspect.\n\nRelevance for Specific Tasks:\n   - This service is crucial for tasks that require dynamic control adjustments, such as switching between different control strategies or adding new control capabilities on-the-fly. It is particularly useful in scenarios where the robot needs to adapt to changing environments or tasks.\n\nUsage in the ROS2 System:\n   - It is suitable for tasks like initializing new controllers during runtime, managing multiple controllers, and ensuring that the robot can handle various control demands without restarting the system.",
            "interfaces": [
                {
                    "name": "controller_manager_msgs/srv/LoadController",
                    "details": "# The LoadController service allows you to load a single controller\n# inside controller_manager\n\n# To load a controller, specify the \"name\" of the controller.\n# The return value \"ok\" indicates if the controller was successfully\n# constructed and initialized or not.\n\nstring name\n---\nbool ok"
                }
            ]
        },
        {
            "name": "/controller_manager/reload_controller_libraries",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/controller_manager/reload_controller_libraries` service is used to reload all controller libraries available in the system as plugins. It ensures that the latest versions of controllers are used by reloading them, which can be forced by killing existing controllers.\n\nMobile Robot Module:\n   - This service relates to the control module of a mobile robot, specifically the controller management system.\n\nRelevance for Specific Tasks:\n   - This service is crucial for updating or changing controllers without restarting the entire system. It is particularly useful in scenarios where new control strategies need to be deployed or existing ones updated dynamically.\n\nUsage in the ROS2 System:\n   - It is suitable for tasks involving dynamic reconfiguration of control systems, such as during development or when adapting to new operational requirements. It interacts with the `controller_manager` and is typically used by system integrators and developers.",
            "interfaces": [
                {
                    "name": "controller_manager_msgs/srv/ReloadControllerLibraries",
                    "details": "# The ReloadControllerLibraries service will reload all controllers that are available in\n# the system as plugins\n\n# Reloading libraries only works if there are no controllers loaded. If there\n# are still some controllers loaded, the reloading will fail.\n# If this bool is set to true, all loaded controllers will get\n# killed automatically, and the reloading can succeed.\nbool force_kill\n---\nbool ok"
                }
            ]
        },
        {
            "name": "/controller_manager/set_hardware_component_state",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/controller_manager/set_hardware_component_state` service is used to control the lifecycle of a hardware component in a ROS2 system. It allows users to transition a hardware component between different states such as active, inactive, or finalized.\n\nMobile Robot Module:\n   - This service relates to the hardware interface module of a mobile robot, specifically managing the lifecycle of hardware components.\n\nRelevance for Specific Tasks:\n   - This service is crucial for tasks that require dynamic control over hardware components, such as activating sensors or actuators only when needed to conserve power or ensure safety. It is used in scenarios where hardware components need to be reconfigured or shut down gracefully.\n\nUsage in the ROS2 System:\n   - It is suitable for tasks involving lifecycle management of hardware components, such as initializing sensors during startup, deactivating motors during shutdown, or reconfiguring components during runtime.",
            "interfaces": [
                {
                    "name": "controller_manager_msgs/srv/SetHardwareComponentState",
                    "details": "# The SetHardwareComponentState service allows to control life-cycle of a single hardware component.\n# Supported states are defined in the design document of LifecycleNodes available at:\n# https://design.ros2.org/articles/node_lifecycle.html\n# To control life-cycle of a hardware component, specify its \"name\" and \"target_state\".\n# Target state may be defined by \"id\" using a constant from `lifecycle_msgs/msg/State` or a label\n# using definitions from `hardware_interface/types/lifecycle_state_names.hpp` file.\n# The return value \"ok\" indicates if the component has successfully changed its state to \"target_state\".\n# The return value \"state\" returns current state of the hardware component.\n\nstring name\nlifecycle_msgs/State target_state\n\tuint8 PRIMARY_STATE_UNKNOWN = 0\n\tuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\tuint8 PRIMARY_STATE_INACTIVE = 2\n\tuint8 PRIMARY_STATE_ACTIVE = 3\n\tuint8 PRIMARY_STATE_FINALIZED = 4\n\tuint8 TRANSITION_STATE_CONFIGURING = 10\n\tuint8 TRANSITION_STATE_CLEANINGUP = 11\n\tuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\tuint8 TRANSITION_STATE_ACTIVATING = 13\n\tuint8 TRANSITION_STATE_DEACTIVATING = 14\n\tuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\tuint8 id\n\tstring label\n---\nbool ok\nlifecycle_msgs/State state\n\tuint8 PRIMARY_STATE_UNKNOWN = 0\n\tuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\tuint8 PRIMARY_STATE_INACTIVE = 2\n\tuint8 PRIMARY_STATE_ACTIVE = 3\n\tuint8 PRIMARY_STATE_FINALIZED = 4\n\tuint8 TRANSITION_STATE_CONFIGURING = 10\n\tuint8 TRANSITION_STATE_CLEANINGUP = 11\n\tuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\tuint8 TRANSITION_STATE_ACTIVATING = 13\n\tuint8 TRANSITION_STATE_DEACTIVATING = 14\n\tuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\tuint8 id\n\tstring label"
                }
            ]
        },
        {
            "name": "/controller_manager/set_parameters",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/controller_manager/set_parameters` service allows for the dynamic setting of parameters for controllers in a ROS2 system. It is typically used to adjust controller settings without restarting the system, enabling real-time tuning and configuration.\n\nMobile Robot Module:\n    - This service relates to the control module of a mobile robot, specifically the controller management aspect.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks that require real-time parameter tuning, such as adjusting PID gains for motor controllers or modifying sensor thresholds. It is particularly useful in scenarios where system performance needs to be optimized on-the-fly.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving dynamic reconfiguration of control parameters, such as during system calibration, testing, or when adapting to changing environmental conditions. It is commonly used by nodes that manage or interact with hardware controllers.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParameters",
                    "details": "# A list of parameters to set.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/controller_manager/set_parameters_atomically",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/controller_manager/set_parameters_atomically` service allows for the atomic setting of multiple parameters in a controller. This means that all parameters are set successfully, or none are, ensuring consistency.\n    - It is typically used for updating controller parameters in a synchronized manner without partial updates.\n\nMobile Robot Module:\n    - This service relates to the control module of a mobile robot, specifically the controller management aspect.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks requiring precise and consistent parameter updates, such as tuning control algorithms or adjusting operational parameters on-the-fly.\n    - It plays a role in scenarios where parameter consistency is critical, such as during dynamic reconfiguration or when deploying new control strategies.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving dynamic parameter tuning, real-time control adjustments, and ensuring parameter integrity during updates in a ROS2-based control system.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParametersAtomically",
                    "details": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/controller_manager/switch_controller",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/controller_manager/switch_controller` service allows for the dynamic activation and deactivation of controllers within a single timestep of the controller manager's control loop. It is typically used to manage which controllers are active at any given time, ensuring that the right controllers are operational for the current task.\n\nMobile Robot Module:\n    - This service relates to the control module of a mobile robot, specifically the controller management aspect.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks that require switching between different control strategies or modes, such as transitioning from navigation to manipulation. It ensures that only the necessary controllers are active, optimizing resource usage and system performance.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as switching between different motion controllers in a mobile robot, enabling seamless transitions between different operational modes, and managing controller dependencies and priorities.",
            "interfaces": [
                {
                    "name": "controller_manager_msgs/srv/SwitchController",
                    "details": "# The SwitchController service allows you deactivate a number of controllers\n# and activate a number of controllers, all in one single timestep of the\n# controller manager's control loop.\n\n# To switch controllers, specify\n#  * the list of controller names to activate,\n#  * the list of controller names to deactivate, and\n#  * the strictness (BEST_EFFORT or STRICT)\n#    * STRICT means that switching will fail if anything goes wrong (an invalid\n#      controller name, a controller that failed to activate, etc. )\n#    * BEST_EFFORT means that even when something goes wrong with on controller,\n#      the service will still try to activate/stop the remaining controllers\n#  * activate the controllers as soon as their hardware dependencies are ready, will\n#    wait for all interfaces to be ready otherwise\n#  * the timeout before aborting pending controllers. Zero for infinite\n\n# The return value \"ok\" indicates if the controllers were switched\n# successfully or not.  The meaning of success depends on the\n# specified strictness.\n\n\nstring[] activate_controllers\nstring[] deactivate_controllers\nstring[] start_controllers       # DEPRECATED: Use activate_controllers filed instead\nstring[] stop_controllers        # DEPRECATED: Use deactivate_controllers filed instead\nint32 strictness\nint32 BEST_EFFORT=1\nint32 STRICT=2\nbool start_asap                 # DEPRECATED: Use activate_asap filed instead\nbool activate_asap\nbuiltin_interfaces/Duration timeout\n\tint32 sec\n\tuint32 nanosec\n---\nbool ok"
                }
            ]
        },
        {
            "name": "/controller_manager/unload_controller",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/controller_manager/unload_controller` service is used to unload a specific controller from the controller manager. It is typically used to manage the lifecycle of controllers by removing them when they are no longer needed.\n\nMobile Robot Module:\n   - This service relates to the control module of a mobile robot, specifically the controller management aspect.\n\nRelevance for Specific Tasks:\n   - This service is relevant for tasks involving dynamic reconfiguration of control strategies, such as switching between different control modes or removing faulty controllers. It is useful in scenarios where resource management and system flexibility are critical.\n\nUsage in the ROS2 System:\n   - It is suitable for tasks like dynamically adjusting the control architecture of a robot, such as unloading a velocity controller when switching to a position controller, or during system maintenance and updates.",
            "interfaces": [
                {
                    "name": "controller_manager_msgs/srv/UnloadController",
                    "details": "# The UnloadController service allows you to unload a single controller\n# from controller_manager\n\n# To unload a controller, specify the \"name\" of the controller.\n# The return value \"ok\" indicates if the controller was successfully\n# unloaded or not\n\nstring name\n---\nbool ok"
                }
            ]
        },
        {
            "name": "/joint_trajectory_controller/query_state",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/joint_trajectory_controller/query_state` service allows querying the state of a joint trajectory at a specific time. It provides information on the position, velocity, and acceleration of the joints.\n    - It is typically used for monitoring and verifying the execution of joint trajectories in robotic systems.\n\nMobile Robot Module:\n    - This ROS2 element relates to the Actuation and Motion Control module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks that require real-time feedback on joint states, such as trajectory tracking and motion planning.\n    - It plays a role in scenarios where precise control and adjustment of joint movements are necessary, such as robotic arm manipulation or mobile robot navigation.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving trajectory execution monitoring, such as in robotic arms or mobile platforms that need to ensure accurate movement along a planned path.",
            "interfaces": [
                {
                    "name": "control_msgs/srv/QueryTrajectoryState",
                    "details": "builtin_interfaces/Time time\n\tint32 sec\n\tuint32 nanosec\n---\nbool success   # indicate successful run of triggered service\nstring message # informational, e.g. for error messages\n\nstring[] name\nfloat64[] position\nfloat64[] velocity\nfloat64[] acceleration"
                }
            ]
        },
        {
            "name": "/joint_trajectory_controller/set_parameters",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/joint_trajectory_controller/set_parameters` service allows for the dynamic configuration of parameters related to the joint trajectory controller. It is typically used to adjust control parameters on-the-fly to optimize performance or adapt to changing conditions.\n\nMobile Robot Module:\n    - This service relates to the actuation and control module of a mobile robot, specifically focusing on joint trajectory control.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks requiring precise control of joint movements, such as robotic arm manipulation or mobile robot navigation. It allows for real-time tuning of control parameters to achieve desired motion profiles.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks involving dynamic parameter tuning in applications like robotic arms, autonomous vehicles, and any system requiring adaptive control strategies.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParameters",
                    "details": "# A list of parameters to set.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/joint_trajectory_controller/set_parameters_atomically",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/joint_trajectory_controller/set_parameters_atomically` service allows for the atomic setting of multiple parameters in a joint trajectory controller. This ensures that either all parameters are updated successfully or none are, maintaining system consistency.\n    - It is typically used for configuring or reconfiguring controller parameters in a synchronized manner.\n\nMobile Robot Module:\n    - This ROS2 element relates to the motion control module of a mobile robot, specifically the joint trajectory controller.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks requiring precise control adjustments, such as tuning controller parameters for optimal performance or adapting to new operational conditions.\n    - It plays a role in scenarios where parameter consistency is critical, such as during dynamic reconfiguration or system calibration.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving dynamic parameter tuning, system calibration, and ensuring consistent controller behavior during runtime adjustments.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParametersAtomically",
                    "details": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/lidar_1_sensor_plugin/set_parameters",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/lidar_1_sensor_plugin/set_parameters` service allows for the dynamic configuration of parameters for a LiDAR sensor plugin. It is typically used to adjust sensor settings such as range, resolution, or update rate during runtime.\n\nMobile Robot Module:\n    - This ROS2 element relates to the LiDAR sensor module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks requiring adaptive sensor configurations, such as optimizing sensor performance in varying environmental conditions or during different phases of a mission. It is particularly useful in scenarios where real-time adjustments to sensor parameters can enhance data quality or processing efficiency.\n\nUsage in the ROS2 System:\n    - Suitable for tasks such as autonomous navigation, obstacle detection, and mapping, where LiDAR sensor parameters may need to be tuned dynamically to improve system performance.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParameters",
                    "details": "# A list of parameters to set.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/lifecycle_manager_localization/manage_nodes",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/lifecycle_manager_localization/manage_nodes` service is responsible for managing the lifecycle states of nodes, specifically for localization tasks. It allows for starting, pausing, resuming, resetting, and shutting down nodes, ensuring they are in the correct state for operation.\n\nMobile Robot Module:\n   - This service relates to the Localization module of a mobile robot.\n\nRelevance for Specific Tasks:\n   - It is crucial for managing the lifecycle of localization nodes, ensuring they are correctly initialized and operational. This is essential for tasks requiring precise localization, such as navigation and mapping.\n\nUsage in the ROS2 System:\n   - Suitable for tasks involving the initialization and management of localization nodes, such as during startup sequences or when recovering from errors. It is typically used by lifecycle managers and node controllers in ROS2 systems.",
            "interfaces": [
                {
                    "name": "nav2_msgs/srv/ManageLifecycleNodes",
                    "details": "uint8 STARTUP = 0\nuint8 PAUSE = 1\nuint8 RESUME = 2\nuint8 RESET = 3\nuint8 SHUTDOWN = 4\n\nuint8 command\n---\nbool success"
                }
            ]
        },
        {
            "name": "/lifecycle_manager_navigation/manage_nodes",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/lifecycle_manager_navigation/manage_nodes` service is used to manage the lifecycle states of nodes within the navigation stack. It allows for starting, pausing, resuming, resetting, and shutting down nodes, ensuring that the navigation system operates smoothly and efficiently.\n    - It is typically used for controlling the state transitions of navigation-related nodes to maintain system stability and performance.\n\nMobile Robot Module:\n    - This ROS2 element relates to the Navigation module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks that require dynamic control over the navigation stack, such as starting up the navigation system, pausing it for maintenance or updates, and resuming operations. It ensures that nodes are in the correct state for the robot to navigate effectively.\n    - Typical scenarios include initializing the navigation system at startup, pausing navigation during a critical update, or resetting the system after an error.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as lifecycle management of navigation nodes, ensuring that nodes are correctly initialized and shut down, and maintaining the overall health of the navigation system.",
            "interfaces": [
                {
                    "name": "nav2_msgs/srv/ManageLifecycleNodes",
                    "details": "uint8 STARTUP = 0\nuint8 PAUSE = 1\nuint8 RESUME = 2\nuint8 RESET = 3\nuint8 SHUTDOWN = 4\n\nuint8 command\n---\nbool success"
                }
            ]
        },
        {
            "name": "/object_controller/set_parameters",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/object_controller/set_parameters` service allows for the dynamic configuration of parameters in a ROS2 system. It is typically used to adjust the behavior of nodes by setting parameters at runtime.\n\nMobile Robot Module:\n    - This service relates to the control module of a mobile robot, specifically for configuring control algorithms or behavior settings.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks that require real-time tuning of control parameters, such as adjusting PID gains or setting thresholds for sensor data processing. It is used in scenarios where flexibility and adaptability of control strategies are needed.\n\nUsage in the ROS2 System:\n    - Suitable for tasks like dynamic reconfiguration of control parameters during navigation, obstacle avoidance, or path planning. It is commonly used by nodes that need to adapt to changing environments or operational conditions.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParameters",
                    "details": "# A list of parameters to set.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/object_controller/set_parameters_atomically",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/object_controller/set_parameters_atomically` service allows for the atomic setting of multiple parameters. This means that either all parameters are set successfully, or none are, ensuring consistency.\n    - It is typically used for configuring parameters of a control node in a reliable manner.\n\nMobile Robot Module:\n    - This service relates to the control module of a mobile robot, particularly in configuring controllers or other parameter-dependent components.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks that require consistent parameter updates, such as tuning control algorithms or adjusting sensor settings.\n    - It plays a role in scenarios where parameter changes need to be applied without partial updates, which could lead to inconsistent behavior.\n\nUsage in the ROS2 System:\n    - Suitable for tasks like dynamic reconfiguration of control parameters, ensuring that all changes are applied simultaneously to avoid system instability.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParametersAtomically",
                    "details": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/slam_toolbox/deserialize_map",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/slam_toolbox/deserialize_map` service is used to load a previously saved map and pose graph into the SLAM (Simultaneous Localization and Mapping) system. It allows the robot to resume mapping or localization from a known state.\n    - It is typically used for continuing SLAM operations after a restart or for initializing the robot's position in a known environment.\n\nMobile Robot Module:\n    - This element relates to the Navigation and Mapping module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks that require the robot to localize itself in a pre-mapped environment or to continue building a map after a pause. It is particularly useful in scenarios where the robot needs to recover from a shutdown or needs to be repositioned accurately in a known map.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as autonomous navigation, where the robot needs to understand its environment to plan paths and avoid obstacles. It is commonly used in conjunction with other SLAM and navigation nodes in ROS2 systems.",
            "interfaces": [
                {
                    "name": "slam_toolbox/srv/DeserializePoseGraph",
                    "details": "int8 UNSET = 0\nint8 START_AT_FIRST_NODE = 1\nint8 START_AT_GIVEN_POSE = 2\nint8 LOCALIZE_AT_POSE = 3\n\n# inital_pose should be Map -> base_frame (parameter, generally base_link)\n#\n\nstring filename\nint8 match_type\ngeometry_msgs/Pose2D initial_pose\n\tfloat64 x\n\tfloat64 y\n\tfloat64 theta\n---"
                }
            ]
        },
        {
            "name": "/slam_toolbox/dynamic_map",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/slam_toolbox/dynamic_map` service provides access to the current map as an `OccupancyGrid`. It is typically used to retrieve the map data generated by SLAM (Simultaneous Localization and Mapping) processes.\n\nMobile Robot Module:\n    - This element relates to the Navigation and Mapping modules of a mobile robot.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks involving navigation and path planning, as it provides the robot with an up-to-date map of its environment. It is particularly useful in dynamic environments where the map needs to be frequently updated.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as autonomous navigation, obstacle avoidance, and environment mapping. Typical ROS2 entities that interact with this service include navigation nodes and path planners that require real-time map data to function effectively.",
            "interfaces": [
                {
                    "name": "nav_msgs/srv/GetMap",
                    "details": "# Get the map as a nav_msgs/OccupancyGrid\n---\n# The current map hosted by this map service.\nOccupancyGrid map\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tMapMetaData info\n\t\tbuiltin_interfaces/Time map_load_time\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tfloat32 resolution\n\t\tuint32 width\n\t\tuint32 height\n\t\tgeometry_msgs/Pose origin\n\t\t\tPoint position\n\t\t\t\tfloat64 x\n\t\t\t\tfloat64 y\n\t\t\t\tfloat64 z\n\t\t\tQuaternion orientation\n\t\t\t\tfloat64 x 0\n\t\t\t\tfloat64 y 0\n\t\t\t\tfloat64 z 0\n\t\t\t\tfloat64 w 1\n\tint8[] data"
                }
            ]
        },
        {
            "name": "/slam_toolbox/manual_loop_closure",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/slam_toolbox/manual_loop_closure` service is used to manually trigger a loop closure in SLAM (Simultaneous Localization and Mapping) processes. It is typically used to correct the robot's map and pose when automatic loop closure detection fails.\n\nMobile Robot Module:\n    - This element relates to the SLAM module of the mobile robot.\n\nRelevance for Specific Tasks:\n    - It solves problems related to map inaccuracies and pose errors by allowing manual intervention in the loop closure process. It is particularly useful in environments where automatic loop closure is challenging due to dynamic changes or lack of distinctive features.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving map correction and pose adjustment in SLAM applications, especially in complex or dynamic environments where manual oversight is necessary.",
            "interfaces": [
                {
                    "name": "slam_toolbox/srv/LoopClosure",
                    "details": "---"
                }
            ]
        },
        {
            "name": "/slam_toolbox/pause_new_measurements",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/slam_toolbox/pause_new_measurements` service is used to toggle the pause state of new measurements in the SLAM (Simultaneous Localization and Mapping) process. It is typically used to temporarily halt the integration of new sensor data into the SLAM algorithm.\n\nMobile Robot Module:\n   - This service relates to the Localization and Mapping module of a mobile robot.\n\nRelevance for Specific Tasks:\n   - This service is useful for controlling when new sensor data should be considered in the SLAM process, which can be critical during tasks that require precise localization without interference from new, potentially noisy data. It is particularly relevant in scenarios where the robot needs to maintain a stable map while performing other operations.\n\nUsage in the ROS2 System:\n   - It is suitable for tasks such as pausing SLAM updates during critical navigation maneuvers or when the robot is stationary and does not require immediate map updates. Typical ROS2 entities that interact with this service include navigation nodes and SLAM management systems.",
            "interfaces": [
                {
                    "name": "slam_toolbox/srv/Pause",
                    "details": "# trigger pause toggle\n\n---\nbool status"
                }
            ]
        },
        {
            "name": "/slam_toolbox/set_parameters_atomically",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n   - The `/slam_toolbox/set_parameters_atomically` service allows for the atomic setting of multiple parameters in the SLAM (Simultaneous Localization and Mapping) toolbox. It ensures that either all parameters are updated successfully or none are, maintaining system consistency.\n\nMobile Robot Module:\n   - This service relates to the SLAM module of a mobile robot, which is crucial for mapping and localization tasks.\n\nRelevance for Specific Tasks:\n   - This service is essential for dynamically adjusting SLAM parameters during operation, such as tuning performance or adapting to new environments. It is particularly useful in scenarios where parameter consistency is critical, such as during live mapping or navigation.\n\nUsage in the ROS2 System:\n   - It is suitable for tasks involving real-time SLAM adjustments, such as during autonomous exploration or when integrating new sensor data.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParametersAtomically",
                    "details": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/spawn_entity",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/spawn_entity` service is used to add new entities, such as robots or objects, into a simulation environment. It is typically used to dynamically introduce elements into a Gazebo simulation by providing their XML description and initial pose.\n\nMobile Robot Module:\n    - This service relates to the simulation module of a mobile robot, particularly when setting up or modifying the simulation environment.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks involving the initialization and configuration of simulation environments. It allows users to test control algorithms by spawning robots or obstacles in different configurations and scenarios.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks such as automated testing of navigation algorithms, where different entities need to be spawned in the simulation to evaluate the robot's response. It is commonly used in conjunction with simulation tools like Gazebo.",
            "interfaces": [
                {
                    "name": "gazebo_msgs/srv/SpawnEntity",
                    "details": "string name                       # Name of the entity to be spawned (optional).\nstring xml                        # Entity XML description as a string, either URDF or SDF.\nstring robot_namespace            # Spawn robot and all ROS interfaces under this namespace\ngeometry_msgs/Pose initial_pose   # Initial entity pose.\n\tPoint position\n\t\tfloat64 x\n\t\tfloat64 y\n\t\tfloat64 z\n\tQuaternion orientation\n\t\tfloat64 x 0\n\t\tfloat64 y 0\n\t\tfloat64 z 0\n\t\tfloat64 w 1\nstring reference_frame            # initial_pose is defined relative to the frame of this entity.\n                                  # If left empty or \"world\" or \"map\", then gazebo world frame is\n                                  # used.\n                                  # If non-existent entity is specified, an error is returned\n                                  # and the entity is not spawned.\n---\nbool success                      # Return true if spawned successfully.\nstring status_message             # Comments if available."
                }
            ]
        },
        {
            "name": "/teleop/set_parameters_atomically",
            "type": "service",
            "description": "Purpose of the ROS2 Element:\n    - The `/teleop/set_parameters_atomically` service allows for the atomic setting of multiple parameters. This means that either all parameters are set successfully, or none are, ensuring consistency.\n    - It is typically used for configuring teleoperation settings in a mobile robot, ensuring that changes are applied safely and consistently.\n\nMobile Robot Module:\n    - This service relates to the teleoperation module of a mobile robot, which is responsible for remote control and command execution.\n\nRelevance for Specific Tasks:\n    - This service is crucial for tasks that require dynamic reconfiguration of teleoperation parameters, such as adjusting speed limits or control sensitivity during operation.\n    - It plays a role in scenarios where parameter consistency is critical, such as during live teleoperation sessions where incorrect settings could lead to unsafe behavior.\n\nUsage in the ROS2 System:\n    - Suitable for ROS2 tasks involving dynamic parameter tuning, such as adjusting control parameters in response to environmental changes or operator commands during teleoperation.",
            "interfaces": [
                {
                    "name": "rcl_interfaces/srv/SetParametersAtomically",
                    "details": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\tstring name\n\tParameterValue value\n\t\tuint8 type\n\t\tbool bool_value\n\t\tint64 integer_value\n\t\tfloat64 double_value\n\t\tstring string_value\n\t\tbyte[] byte_array_value\n\t\tbool[] bool_array_value\n\t\tint64[] integer_array_value\n\t\tfloat64[] double_array_value\n\t\tstring[] string_array_value\n\n---\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\tbool successful\n\tstring reason"
                }
            ]
        },
        {
            "name": "/follow_waypoints",
            "type": "action",
            "description": "Purpose of the ROS2 Element:\n    - The `/follow_waypoints` action is designed to guide a mobile robot through a series of predefined waypoints. It is typically used for navigation tasks where the robot needs to follow a specific path.\n\nMobile Robot Module:\n    - This element relates to the Navigation module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - It solves the problem of path-following by allowing the robot to move through a sequence of waypoints. This is crucial in scenarios such as autonomous delivery, patrol, or exploration where precise navigation is required.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving the `nav2` stack, where it interacts with other navigation components to achieve waypoint following. It is commonly used in conjunction with planners and controllers to ensure smooth and accurate navigation.",
            "interfaces": [
                {
                    "name": "nav2_msgs/action/FollowWaypoints",
                    "details": "#goal definition\ngeometry_msgs/PoseStamped[] poses\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n---\n#result definition\nint32[] missed_waypoints\n---\n#feedback definition\nuint32 current_waypoint"
                }
            ]
        },
        {
            "name": "/joint_trajectory_controller/follow_joint_trajectory",
            "type": "action",
            "description": "Purpose of the ROS2 Element:\n    - The `/joint_trajectory_controller/follow_joint_trajectory` action is used to control the movement of robot joints by following a specified trajectory. It is typically used for precise joint control in robotic arms or mobile robots with articulated joints.\n\nMobile Robot Module:\n    - This ROS2 element relates to the Actuation and Motion Planning modules of a mobile robot, specifically those involving joint control.\n\nRelevance for Specific Tasks:\n    - This element is crucial for tasks requiring precise joint movements, such as robotic arm manipulation, path following, and coordinated multi-joint movements. It ensures that joints follow a predefined path with specified tolerances.\n\nUsage in the ROS2 System:\n    - It is suitable for tasks like robotic arm control in manufacturing, autonomous vehicle steering, and any application requiring coordinated joint movements. It interacts with entities like `trajectory_msgs/JointTrajectory` and `control_msgs/action/FollowJointTrajectory`.",
            "interfaces": [
                {
                    "name": "control_msgs/action/FollowJointTrajectory",
                    "details": "# The trajectory for all revolute, continuous or prismatic joints\ntrajectory_msgs/JointTrajectory trajectory\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tstring[] joint_names\n\tJointTrajectoryPoint[] points\n\t\tfloat64[] positions\n\t\tfloat64[] velocities\n\t\tfloat64[] accelerations\n\t\tfloat64[] effort\n\t\tbuiltin_interfaces/Duration time_from_start\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n# The trajectory for all planar or floating joints (i.e. individual joints with more than one DOF)\ntrajectory_msgs/MultiDOFJointTrajectory multi_dof_trajectory\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tstring[] joint_names\n\tMultiDOFJointTrajectoryPoint[] points\n\t\tgeometry_msgs/Transform[] transforms\n\t\t\tVector3 translation\n\t\t\t\tfloat64 x\n\t\t\t\tfloat64 y\n\t\t\t\tfloat64 z\n\t\t\tQuaternion rotation\n\t\t\t\tfloat64 x 0\n\t\t\t\tfloat64 y 0\n\t\t\t\tfloat64 z 0\n\t\t\t\tfloat64 w 1\n\t\tgeometry_msgs/Twist[] velocities\n\t\t\tVector3  linear\n\t\t\t\tfloat64 x\n\t\t\t\tfloat64 y\n\t\t\t\tfloat64 z\n\t\t\tVector3  angular\n\t\t\t\tfloat64 x\n\t\t\t\tfloat64 y\n\t\t\t\tfloat64 z\n\t\tgeometry_msgs/Twist[] accelerations\n\t\t\tVector3  linear\n\t\t\t\tfloat64 x\n\t\t\t\tfloat64 y\n\t\t\t\tfloat64 z\n\t\t\tVector3  angular\n\t\t\t\tfloat64 x\n\t\t\t\tfloat64 y\n\t\t\t\tfloat64 z\n\t\tbuiltin_interfaces/Duration time_from_start\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\n# Tolerances for the trajectory.  If the measured joint values fall\n# outside the tolerances the trajectory goal is aborted.  Any\n# tolerances that are not specified (by being omitted or set to 0) are\n# set to the defaults for the action server (often taken from the\n# parameter server).\n\n# Tolerances applied to the joints as the trajectory is executed.  If\n# violated, the goal aborts with error_code set to\n# PATH_TOLERANCE_VIOLATED.\nJointTolerance[] path_tolerance\n\t#\n\tstring name\n\tfloat64 position  #\n\tfloat64 velocity  #\n\tfloat64 acceleration  #\nJointComponentTolerance[] component_path_tolerance\n\tuint16 X_AXIS=1\n\tuint16 Y_AXIS=2\n\tuint16 Z_AXIS=3\n\tuint16 TRANSLATION=4\n\tuint16 ROTATION=5\n\tstring joint_name\n\tuint16 component\n\tfloat64 position\n\tfloat64 velocity\n\tfloat64 acceleration\n\n# To report success, the joints must be within goal_tolerance of the\n# final trajectory value.  The goal must be achieved by time the\n# trajectory ends plus goal_time_tolerance.  (goal_time_tolerance\n# allows some leeway in time, so that the trajectory goal can still\n# succeed even if the joints reach the goal some time after the\n# precise end time of the trajectory).\n#\n# If the joints are not within goal_tolerance after \"trajectory finish\n# time\" + goal_time_tolerance, the goal aborts with error_code set to\n# GOAL_TOLERANCE_VIOLATED\nJointTolerance[] goal_tolerance\n\t#\n\tstring name\n\tfloat64 position  #\n\tfloat64 velocity  #\n\tfloat64 acceleration  #\nJointComponentTolerance[] component_goal_tolerance\n\tuint16 X_AXIS=1\n\tuint16 Y_AXIS=2\n\tuint16 Z_AXIS=3\n\tuint16 TRANSLATION=4\n\tuint16 ROTATION=5\n\tstring joint_name\n\tuint16 component\n\tfloat64 position\n\tfloat64 velocity\n\tfloat64 acceleration\nbuiltin_interfaces/Duration goal_time_tolerance\n\tint32 sec\n\tuint32 nanosec\n\n---\nint32 error_code\nint32 SUCCESSFUL = 0\nint32 INVALID_GOAL = -1\nint32 INVALID_JOINTS = -2\nint32 OLD_HEADER_TIMESTAMP = -3\nint32 PATH_TOLERANCE_VIOLATED = -4\nint32 GOAL_TOLERANCE_VIOLATED = -5\n\n# Human readable description of the error code. Contains complementary\n# information that is especially useful when execution fails, for instance:\n# - INVALID_GOAL: The reason for the invalid goal (e.g., the requested\n#   trajectory is in the past).\n# - INVALID_JOINTS: The mismatch between the expected controller joints\n#   and those provided in the goal.\n# - PATH_TOLERANCE_VIOLATED and GOAL_TOLERANCE_VIOLATED: Which joint\n#   violated which tolerance, and by how much.\nstring error_string\n\n---\nstd_msgs/Header header\n\tbuiltin_interfaces/Time stamp\n\t\tint32 sec\n\t\tuint32 nanosec\n\tstring frame_id\nstring[] joint_names\ntrajectory_msgs/JointTrajectoryPoint desired\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\ntrajectory_msgs/JointTrajectoryPoint actual\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\ntrajectory_msgs/JointTrajectoryPoint error\n\tfloat64[] positions\n\tfloat64[] velocities\n\tfloat64[] accelerations\n\tfloat64[] effort\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\n\nstring[] multi_dof_joint_names\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_desired\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_actual\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec\ntrajectory_msgs/MultiDOFJointTrajectoryPoint multi_dof_error\n\tgeometry_msgs/Transform[] transforms\n\t\tVector3 translation\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion rotation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\n\tgeometry_msgs/Twist[] velocities\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tgeometry_msgs/Twist[] accelerations\n\t\tVector3  linear\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tVector3  angular\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\tbuiltin_interfaces/Duration time_from_start\n\t\tint32 sec\n\t\tuint32 nanosec"
                }
            ]
        },
        {
            "name": "/navigate_through_poses",
            "type": "action",
            "description": "Purpose of the ROS2 Element:\n    - The `/navigate_through_poses` action is used to command a mobile robot to navigate through a series of predefined poses. It is typically used for path planning and execution in autonomous navigation tasks.\n\nMobile Robot Module:\n    - This ROS2 element relates to the navigation module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - It solves the problem of guiding a robot through multiple waypoints, ensuring it follows a specific path. This is crucial in scenarios like warehouse automation, where a robot must follow a precise route to perform tasks such as inventory management or delivery.\n\nUsage in the ROS2 System:\n    - Suitable for tasks involving autonomous navigation, such as patrol routes, delivery missions, or any application requiring a robot to follow a complex path through multiple points. It interacts with navigation planners and controllers within the ROS2 ecosystem.",
            "interfaces": [
                {
                    "name": "nav2_msgs/action/NavigateThroughPoses",
                    "details": "#goal definition\ngeometry_msgs/PoseStamped[] poses\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\nstring behavior_tree\n---\n#result definition\nstd_msgs/Empty result\n---\n#feedback definition\ngeometry_msgs/PoseStamped current_pose\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\nbuiltin_interfaces/Duration navigation_time\n\tint32 sec\n\tuint32 nanosec\nbuiltin_interfaces/Duration estimated_time_remaining\n\tint32 sec\n\tuint32 nanosec\nint16 number_of_recoveries\nfloat32 distance_remaining\nint16 number_of_poses_remaining"
                }
            ]
        },
        {
            "name": "/navigate_to_pose",
            "type": "action",
            "description": "Purpose of the ROS2 Element:\n    - The `/navigate_to_pose` action is used to command a mobile robot to move to a specified position and orientation in space. It is typically used for navigation tasks where precise movement to a target location is required.\n\nMobile Robot Module:\n    - This ROS2 element relates to the Navigation module of a mobile robot.\n\nRelevance for Specific Tasks:\n    - It solves the problem of autonomous navigation by allowing the robot to plan and execute a path to a given pose. Typical scenarios include moving to a waypoint in a map or reaching a specific location in an environment.\n\nUsage in the ROS2 System:\n    - This action is suitable for tasks such as autonomous delivery, patrol, or exploration, where a robot needs to navigate to specific coordinates. It is commonly used in conjunction with navigation stacks like Nav2.",
            "interfaces": [
                {
                    "name": "nav2_msgs/action/NavigateToPose",
                    "details": "#goal definition\ngeometry_msgs/PoseStamped pose\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\nstring behavior_tree\n---\n#result definition\nstd_msgs/Empty result\n---\n#feedback definition\ngeometry_msgs/PoseStamped current_pose\n\tstd_msgs/Header header\n\t\tbuiltin_interfaces/Time stamp\n\t\t\tint32 sec\n\t\t\tuint32 nanosec\n\t\tstring frame_id\n\tPose pose\n\t\tPoint position\n\t\t\tfloat64 x\n\t\t\tfloat64 y\n\t\t\tfloat64 z\n\t\tQuaternion orientation\n\t\t\tfloat64 x 0\n\t\t\tfloat64 y 0\n\t\t\tfloat64 z 0\n\t\t\tfloat64 w 1\nbuiltin_interfaces/Duration navigation_time\n\tint32 sec\n\tuint32 nanosec\nbuiltin_interfaces/Duration estimated_time_remaining\n\tint32 sec\n\tuint32 nanosec\nint16 number_of_recoveries\nfloat32 distance_remaining"
                }
            ]
        }
    ]
}